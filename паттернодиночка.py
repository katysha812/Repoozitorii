class Singleton:
    _instance = None  # Хранит единственный экземпляр класса

    def __new__(cls):
        if cls._instance is None:  # Если экземпляр еще не создан
            cls._instance = super(Singleton, cls).__new__(cls)
        return cls._instance  # Возвращаем уже созданный экземпляр

# Использование
singleton1 = Singleton()
singleton2 = Singleton()

print(singleton1 is singleton2)  # Вывод: True
'''

### Объяснение кода:

1. Создание класса `Singleton`:
   - В классе объявляется статическая переменная `_instance`, которая будет хранить экземпляр класса.

2. Метод `__new__`:
   - Переопределаем метод `__new__`, который отвечает за создание экземпляра класса.
   - При первом вызове `__new__`, проверяем, создан ли уже экземпляр (`cls._instance`).
   - Если экземпляр ещё не создан, с помощью `super()` вызываем метод `__new__` родительского класса и создаём новый экземпляр.
   - Если экземпляр уже существует, просто возвращаем его.
  
3. Создание объектов:
   - При создании нескольких объектов `singleton1` и `singleton2`, они все будут указывать на один и тот же экземпляр класса `Singleton`.

4. Проверка:
   - `print(singleton1 is singleton2)` проверяет, ссылаются ли оба объекта на один и тот же экземпляр. В результате будет `True`, что подтверждает, что это действительно одиночка.

Этот код очень простой и демонстрирует основную идею паттерна "Одиночка".
'''